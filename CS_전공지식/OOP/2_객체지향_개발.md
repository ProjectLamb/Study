<style>
    h3.quest { font-weight: bold; border: 3px solid; color: #A0F !important;}
    .quest { font-weight: bold; color: #A0F;}
    h2 { border-top: 12px solid #D40; border-left: 5px solid #D40; border-right: 5px solid #D40; background-color: #D40; color: #FFF !important; font-weight: bold;}

    h3 { border-top: 3px solid #FFF; border: 2px solid #FFF; background-color: #FFF; color: #F50 !important;}

    h4 { font-weight: bold; color: #FFF !important; }
</style>

## 📕 2. 객체지향 개발
### 📄 1. OOP(C#)
C#의 객체지향 개발에 관해 다룰것 이다.
#### 특징
* C#에서는 단일 상속만 허용됩니다.
* 클래스 인터페이스의 구현은 여려개도 된다.
* 
<img src="./image/2022-12-23-16-12-14.png">

### 📄 2. Class & Instance

```java
class Calculator //클래스(공장)
{
  int left, right;
  public void setOprands(int left, int right){
    this.left = left;
    this.right = right;
  }
  public void sum(){System.out.println(this.left + this.right);}
  public void avg(){System.out.println((this.left + this.right)/2);}
}

public static void main(String[]args){
  Calculator c1 = new Calculator(); 
    //인스턴스(제품)
  c1.메소드();
}
```

### 📄 접근 한정자

* 어셈블리는 단일 컴파일에서 하나 이상의 .cs 파일을 컴파일하여 만든 .dll또는.exe
* 즉, 개발에서는 namespace가 다르다? 그렇다면 어셈블리가 다른것.
  * [어셈블리가 뭔 개소리? ㅋㅋ](./어셈블리/Csharp에서_어셈블리.md);

* 요약테이블
    |호출자의 위치| public | protected | internal | private |
    |:--|:--|:--|:--|:--|
    |**클래스** 내부 끼리            |✔️️|✔️️|✔️️|✔️️|
    |**파생** 클래스 끼리 (Same 어셈)|✔️️|✔️️|✔️️|❌|
    |**비파생** 클래스 끼리(Same 어셈)|✔️️|❌|✔️️|❌|
    |**파생** 클래스 끼리(diff 어셈)|✔️️|✔️️|❌|❌|
    |**비파생** 내부 끼리(diff 어셈)|✔️️|❌|❌|❌|

### 📄 Static 변수
### 📄 클래스의 this
#### 왜 쓰는건가?
*Doc이나, 블로그 돌아나니면서 알아본 결과..* 

this.멤버변수 : 매개 변수와 객체 자신이 가지고 있는 변수의 이름이 같은 겨우 이를 구분하기 위해 this 를 붙인다.
매개변수와 멤버변수의 이름이 같습니다. 이런 때 this 를 사용하여 구분할 수 있습니다.
this 를 사용하면 지금 다루는 데이터가 인스턴스라는 것을 알 수 있습니다.
필드(전역변수)와 메소드 또는 생성자의 매개변수가 동일할 때 인스턴스 필드임을 명확히 하기 위해 사용한다.

### 📄 구조체

#### 1. 클래스 VS 구조체 
||Class|Struct|
|:--|:--|:--|
|타입|Reference|Value|
|메모리할당|Heap|Stack|
(타입차이에 따른 메모리 할당)
* stack 
  * 지역 변수를 저장하며, 실행 중인 함수를 찾아 계산을 수행함
  * 변수들은 Stack으로 저장(후입선출)
* heap
  * 참조 타입들이 이 곳에 할당된다.
  * 메모리 누수의 대상이 된다.

#### 2. 사용법
* new로 생성하지 않아도 바로 사용할 수 있다
* new 해도 힙영역으로 안가서 좋다는듯.
##### 구조체가 가능한것
1. 프로퍼티 : get, set 
    ```cs
    class _className_ 
    {
        _type_ _fildName_;
        _접근한정자_ _type_ _프로퍼티명_{get; set;}

        _접근한정자_ _type_ _프로퍼티명_
        {
            get{return;}
            set{return;}
        }
    }
    ```
2. 생성자
3. 이벤트
#### 3. 클래스 써버리지 뭘.. 왜?
* 아까말했듯 클래스는 힙영역에 할당된다.
가비지컬렉터가 덜 일해도 된다. 
매서드가 필요없는 단순한 타입엔 구조체가 딱좋다~!
* 그리고 생성자 오버로딩에 사용되기도 한다.

#### 4. 참조 
[① C# 구조체를 써야하는 이유](https://dhy948.tistory.com/13)
[② C# 구조체 (프로퍼티 & 생성자 & 이벤트)](https://www.tutorialsteacher.com/csharp/csharp-struct)
* property & constructor & event
    ```cs
    public struct Coords {
        private int _x, _y;
        public Coordinate(int x, int y) { this.x = x; this.y = y; }
            // 2. 생성자 
                //_접근한정자_ _type_ _프로퍼티명_{get{...}; set{...};}
        public int x //1. property
        {
            get{ return _x; }
            set{ _x = value; CoordinatesChanged(_x);}
        }
        public int y //1. property
        {
            get{ return _y; }
            set{ _y = value; CoordinatesChanged(_y);}
        }
        public event Action<int> CoordinatesChanged;
            //3. 이벤트
    }
    ```
* 좌표가 변경 될 때 발생하는 CoordinatesChanged event 가 포함되어 있습니다. 
* 다음 예제는 이벤트 처리를 보여줍니다. xyCoordinatesChanged
    ```cs
    class Program
    {
        static void Main(string[] args) {
            Coordinate point = new Coordinate();   
            point.CoordinatesChanged += StructEventHandler;
            point.x = 10; point.y = 20;
        }

        static void StructEventHandler(int point) {
            Console.WriteLine("Coordinate changed to {0}", point);
        }
    }
    ```

### 📄 인터페이스