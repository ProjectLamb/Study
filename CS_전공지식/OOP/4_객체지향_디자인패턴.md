---
ebook:
  theme: github-light.css
  title: 객체지향
  authors: Escatrgot
  disable-font-rescaling: true
  margin: [0.1, 0.1, 0.1, 0.1]
---
<style>
    h3.quest { font-weight: bold; border: 3px solid; color: #A0F !important;}
    .quest { font-weight: bold; color: #A5F !important;}
    h2 { border-top: 12px solid #D40; border-left: 5px solid #D40; border-right: 5px solid #D40; background-color: #D40; color: #FFF !important; font-weight: bold;}
    h3 { border-top: 12px solid #F90; border: 5px solid #F90; background-color: #F90; color: #FFF !important;}
</style>

## 📕 4. 객체지향 디자인 패턴

#### 유니티에서 사용하면 좋을 디자인 패턴만 명시한다.

---
### 📄 1. 디자인패턴 개요
#### 1). 디자인패턴 왜 배우나? 
**통계적으로 발생되는 문제 23개 패턴 <br>읽기쉽게 이해하기쉽고 수정하기쉬운 코드로 만들기 위해**

#### 2). 종류
1. **생성** 패턴 : 5
2. **구조** 패턴 : 7
3. **행위** 패턴 : 11

#### 3). 아키텍쳐 패턴 VS 디자인 패턴
* **아키텍쳐 패턴** : 시스템 구조에 대한 가이드 라인 
  * 모듈 & 컴포넌트를 어떻게 배치할지
* **디자인 패턴** : 모듈의 세분화된 역활 & 보듈간의 인터페이스를 상세 구현할때 쓰는 가이드 라인

---

### 📄 2. SOLID Principle 
#### 1). SRP (Single Responsibility Principle)
<p align="center">
    <img src="./image/2022-12-28-12-09-08.png" width=400px>
</p>

**ⓐ 단일 책임 원칙**
* 클만변
    1. 클래스 만들때
       * 걔는 단 하나의 책임을 가져야한다
    2. 클래스 변경할때
       * 걔는 단 한가지 이유가 있어야한다

* 높은 응집력과 낮은 결합

**ⓑ 예시**
* [SRP BAD 🤪](./src/SOLID/SRP_BAD.cs)
* [SRP GOOD 😎](./src/SOLID/SRP_GOOD.cs)
* [Python : SRP 비준수와 준수](./src/SOLID/SRP비준수준수.py)

#### 2). OCP (Open-Closed Principle) 

<p align="center">
    <img src="./image/2022-12-28-12-30-32.png" width=400px>
</p>

**ⓐ 확장-폐쇠 원칙**

* 확변
    1. 확장시
       * 열려있어야함
    2. 변경시
       * 닫혀있어야함

**ⓑ 정확한 설명**

* 
    ```text
    1. 새로운 기능을 추가싶을때 있다.
    2. 그런데 추가 시킬때마다 만들었던 코드를 수정해야된다면
    3. 너무 불편하지 않겠나? (애초에 수정이라는 과정에서 버그가 발생하기 마련이다)
    4. 그러지말고 그냥 한줄만 추가해도 기능 확장이 쉬운 구조로 만들자는것
    ```

**ⓒ 예시**
* [OCP BAD 🤪](./src/SOLID/OCP_BAD.cs)
* [OCP 준수 😎](./src/SOLID/OCP_GOOD.cs)
* [Python : OCP 비준수 코드](./src/SOLID/OCP비준수.py)  : <br> Cow와 Sheep을 추가하기위해 hey함수의 수정이 필요하다.
* [Python : OCP 준수 코드](./src/SOLID/OCP준수.py) : <br> 추가되는 동물에 대해 hey함수의 수정을 필요로 하지 않는다

#### 3). LSP (리스코프 Substitute Principle) 
<p align="center">
    <img src="./image/2022-12-28-12-48-22.png" width=400px>
</p>

**ⓐ 리스코프 치환 원칙**
* 상위 클래스가 하위 클래스로 치환될때 문제없이 잘 돌아가야한다.
  * we can use any inheriting class in place of the base class.

* **[LSP 예시](./src/SOLID/LSP준수비준수.py)**

#### 4). ISP (Interface Segregation Principle) ❓

<p align="center">
    <img src="./image/2022-12-28-13-07-25.png" width=400px>
</p>

**ⓐ 인터페이스 분리 원칙**

커버져린 인터페이스 사용시 사용하지도 않을 인터페이스가 
클래스로 들어오게 된다면?..

* 뚱뚱한 인터페이스를 사용 해서는 안된다.
  * 클라이언트는 사용하지도 않을 메소드들에게
의존하게 해선 안된다 인터페이스를 더 작은 단위로 나누자
  * ![](./image/IS.png)
  * 
    ```text
    1. 자동차 인터페이스는 
         * 자동차 인터페이스 클래스만
    2. 보트 인터페이스는 
         *  보트 인터페이스 클래스만
    3. 만약 양육자동차려면
         * 자동차 보트 인터페이스 둘다 가져오기
    ```

**ⓑ 예시**
* **[Python : ISP 준수 비준수](./src/SOLID/ISP준수비준수.cs)**

#### 5). DIP (Dependency Inverse Principle) ❓

<p align="center">
    <img src="./image/2022-12-28-13-08-29.png" width=400px>
    <img src="./image/2022-12-29-00-08-43.png" width=400px>
</p>

**ⓐ 의존 역전 원칙**

* "추상화에 의존하라"
  * 구체적인 개념보다는 추상적인 개념에 의존해야 한다.

* 변동성이 큰 클래스로부터 파생하지 말자, 대신 추상 팩토리로 파생하여 확장성을 높이자
* 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장합니다.

**ⓑ Hook 메소드 란?**
  1. *[1) Virtual 하게 정의]* 해두거나 *[2) 비워진 (추상적으로)]* 수퍼 클래스에 정의된 메소드이며,

* 특정 구현에 대한 종속성을 줄여야 하지만 인터페이스에 의존해야 합니다.

**ⓑ 예시**
* [DIP_BAD 🤪](./src/SOLID/DIP_BAD.cs)
* [DIP_GOOD 😎](./src/SOLID/DIP_GOOD.cs)
* [Python : DIP_비준수](./src/SOLID/DIP비준수.py)
* [Python : DIP_준수](./src/SOLID/DIP준수.py)

---

### 📄 3. 생성 패턴

<div align="center">
  <h4> 생성과 참조과정을 캡슐화 하여 객체가 생성되거나 변경되도 <br>
  시스템에 영향을 크게 받지 않도록 프로그램의 유연성을 더해주는 패턴</h4>
</div>

#### 1). ✨ 싱글톤 ✨

<p align="center">
    <img src="2022-12-29-01-25-31.png" width=400px>
</p>



**ⓐ 특징**

1. 전역적으로 접근 가능한 객체라 어디에서든지 참조할 수 있다.
2. ***인스턴스가 오직 단 하나를 상성함을 보장***, 불필요한 메모리 낭비를 최소화 할 수 있다
3. 너무 남용하면 다른 클래스의 인스턴스들 간에 결합도가 높아져 개방 폐쇠 원칙이 위배될 수 있다.

**ⓑ 사용하는 이유**
* 전역적으로 사용되는 데이터, 리소스를 수시로 접근해야 할때
* GameManager 힘들게 지정하는 대신 쉽게 Static으로 접근 가능

**ⓒ 다음과 같은 목적에 사용하기를 권한다.**
1. 환경설정
    * Audio Manager
2. Save & Load
    * 단 동기화 문제가 없을시.
3. Camera : 사실 이미 유니티에 Camera.main으로 구현되어있음
4. EventSystem : 사실 이미 유니티에 구현되어 있음
5. 싱글톤 GameObject를 생성해서 사용. GameLoop가 없는 객체로만.
    ```cs
    public class _className_ : monoBehavier {
      private static _className_ _instance;

      public static _className_ Instanace {
        get{
          if(_instance == null){
            var obj = FindObjectType<_classNmae_>();

            if(obj != null){_instance = obj}
            else if(obj == null) {
              var newObj = new GameObject().AddComponent<_className_>();
              return _instance;
            }
          }
        private set;
        }
      }
    }
    ```

**ⓓ 사용해서는 안되는 상황**
1. 플레이서, 몹, 이펙트
   * 개발 과정에서 결합도가 높아지는 경우가 있음
   * 게다가 Static 변수는 디버깅 트랙하기 힘들다 즉, 어디서 일어난 버그인지..

**ⓔ 구현시 고려해야할 상황**

1. **동시성 문제** : 싱글톤 생성이 느리면 모든 쓰레드가 거의 동시에 도착하고
이로인해 서로가 null 객체를 바라보기 때문에 쓰레드들이 **객체를 두번 생성할 수 있다**.
   * 인스턴스가 하나만 있기를 보장해야하는데 불구하고..;
   * ***해결책 : Thread-Safe 가 보장되어야 한다.***
* 
  ```cs
  public class LazySingleton {
    private static readonly Lazy<LazySingleton> _instance
      = new Lazy<LazySingleton>(() => new LazySingleton());

    public static LazySingleton Instance {
        get { return _instance.Value; }
    }
    private LazySingleton() { }
  }
  ```

2. **프레임 드랍** : 필요할 때 초기화한다는 건 그 순간을 최대한 미룰 수 있어 괜찮은 아이디어입니다. 하지만 전투 도중에 시스템 초기화 작업을 수행한다면 중간에 프레임이 떨어지거나 게임 화면이 뚝뚝 끊길 수도 있겠죠. 가능하면 로딩 씬에서 이를 모두 초기화한다면 게임 플레이에 영향이 적을 테니 좋겠죠. 
   * **시작과 동시에 정적 변수를 초기화**

* 
  ```cs
  public class Singleton {
    private static readonly Singleton _instance = new Singleton();

    public static Singleton Instance {
      get {
          if(_instance == null) return new Singleton();
          return _instance;
      }
    }
  }
  ```
### 📄 4. 구조 패턴

클래스나 객체를 조합하여 더 큰구조로 만드는 패턴

#### 1). 플라이 웨이트
* 인스턴스가 필요할 때마다 매번 생성하는것이 아닌 가능한 공유를 통해 사용함으로 메모리를 절약하는 패턴
* 다수의 유사객체를 사용하거나 조작할떄 유용

#### 2). 데코레이터
* 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴
* 객체간 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴

* 임의의 객체에 부가적인 기능을 추가하기위해 다른 객체를 덧붙이는 방식으로 구현함

### 📄 5. 행동 패턴

클래스와 객체간 서로 상호작용하는 방법이나 책임 분배 방법을 정의
하나의 객체로 수행할 수 없는작업을 여러 객체로 분해하면서 결합도를 낮출수 있음

#### 1). ✨ Command ✨
* Express actions for actors as classes.
* 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
* 요청을 객체 형태로 캡슐화 하여 재이용하거나 취소 할수 있도록 
필요 정보를 저장하거나 로그에 남기는 패턴
* 요청에 사용되는 명령어를 추상클래스나 구체 클래스로 분리하여 단순화 시킴

#### 2). ✨ Observer ✨
* An object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes.
* 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴
* 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게도 변화된 상태를 전달하는 패턴
* 주로 분산된 시스템간에 이벤트를 생성 발행하고 이를 수신해야할떄 이용함

#### 3). State
* 객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴
* 객체의 상태에 따라 동일한 동작을 다르게 처리해야할떄,
* 객체 상태를 캡슐화 하여 이를 참조하는 방식

### 📄 6. 그밖에 Unity에 유용한 패턴

#### 1). Subclass Sandbox : Behavioral Patterns
* Define behavior in a subclass using a set of operations provided by its base class.

#### 2). Event queue : Decoupling Patterns
* Decouple when a message or event is sent from when it is processed.

#### 3). ✨ Object Pool ✨ : Optimization Patterns
* Improve performance and memory use by reusing objects from a fixed pool instead of allocating and freeing them individually.

### 📄 6. 참고

1. [코드없는 프로그래밍 SOLID](https://www.youtube.com/watch?v=jlQkWM7Tu7o&list=PLDV-cCQnUlIZcWXE4PrxJx6U3qKfRTJcK&index=1)
2. https://github.com/accesto/solid-php
3. https://accesto.com/blog/solid-php-solid-principles-in-php/

4. https://korstrix.github.io/index/Index/
5. https://github.com/Habrador/Unity-Programming-Patterns
6. https://csharpindepth.com/articles/singleton
7. https://gameprogrammingpatterns.com/contents.html

[싱글톤 개요](https://cjw-awdsd.tistory.com/42)
[싱글톤 c#](http://egloos.zum.com/sweeper/v/3157853)
[싱글톤 c#](https://nochoco-lee.tistory.com/676)
[Master Singleton: in unity the right way](https://gamedevbeginner.com/singletons-in-unity-the-right-way/)
[Master Singleton Video](https://www.youtube.com/watch?v=tcatvGLvCDc)